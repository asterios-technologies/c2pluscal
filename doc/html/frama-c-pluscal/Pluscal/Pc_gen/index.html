<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Pc_gen (frama-c-pluscal.Pluscal.Pc_gen)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.0.0_beta1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> ‚Äì <a href="../../../index.html">üè†</a> &#x00BB; <a href="../../index.html">frama-c-pluscal</a> &#x00BB; <a href="../index.html">Pluscal</a> &#x00BB; Pc_gen</nav><header class="odoc-preamble"><h1>Module <code><span>Pluscal.Pc_gen</span></code></h1><p>Generates PlusCal code from a given Frama-C program. The PlusCal code is generated by traversing the Frama-C AST and converting each element into its corresponding PlusCal representation. *</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec value anchored" id="val-pc_of_unop"><a href="#val-pc_of_unop" class="anchor"></a><code><span><span class="keyword">val</span> pc_of_unop : <span><span class="xref-unresolved">Frama_c_kernel</span>.Cil_types.unop <span class="arrow">&#45;&gt;</span></span> <a href="../Pc/index.html#type-pc_unop">Pc.pc_unop</a></span></code></div><div class="spec-doc"><p>Converts a unary operation to its corresponding PlusCal representation.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">unop</span> <p>unary operation to convert.</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p><code>Result</code> containing the PlusCal unary operation or an error message. *</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pc_of_binop"><a href="#val-pc_of_binop" class="anchor"></a><code><span><span class="keyword">val</span> pc_of_binop : <span><span class="xref-unresolved">Frama_c_kernel</span>.Cil_types.binop <span class="arrow">&#45;&gt;</span></span> <a href="../Pc/index.html#type-pc_binop">Pc.pc_binop</a></span></code></div><div class="spec-doc"><p>Converts a unary operation to its corresponding PlusCal representation.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">binop</span> <p>binary operation to convert.</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p><code>Result</code> containing the PlusCal binary operation or an error message. *</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pc_of_cst"><a href="#val-pc_of_cst" class="anchor"></a><code><span><span class="keyword">val</span> pc_of_cst : 
  <span><span class="xref-unresolved">Frama_c_kernel</span>.Cil_types.constant <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../Pc/index.html#type-pc_cst">Pc.pc_cst</a>, string)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p>Converts a constant to a PlusCal expression.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">cst</span> <p>constant to convert.</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p><code>Result</code> containing the PlusCal constant or an error message.</p></li></ul><p>The function does not handle the following cases :</p><ul><li><code>CWStr</code> : Wide character string</li><li><code>CReal</code> : Floating point number *</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pc_of_exp"><a href="#val-pc_of_exp" class="anchor"></a><code><span><span class="keyword">val</span> pc_of_exp : 
  <span><span class="xref-unresolved">Frama_c_kernel</span>.Cil_types.exp_node <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../Pc/index.html#type-pc_expr">Pc.pc_expr</a>, string)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p>Recursively translates an expression into its PlusCal representation.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">exp</span> <p>expression to be translated.</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p><code>Result</code> containing the PlusCal expression or an error message.</p></li></ul><p>The function does not handle the following cases :</p><ul><li><code>SizeOf</code></li><li><code>AlignOf</code> *</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pc_of_mec_access"><a href="#val-pc_of_mec_access" class="anchor"></a><code><span><span class="keyword">val</span> pc_of_mec_access : 
  <span><span class="xref-unresolved">Frama_c_kernel</span>.Cil_types.exp <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../Pc/index.html#type-pc_lval">Pc.pc_lval</a>, string)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p>Translates a memory access expression <code>e</code> into a PlusCal expression. It uses the <code>pc_of_exp</code> function to convert the expression node <code>e.enode</code> into a PlusCal expression.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">e</span> <p>expression to be translated.</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p><code>Result</code> containing the translated PlusCal expression or an error message. *</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pc_of_lval"><a href="#val-pc_of_lval" class="anchor"></a><code><span><span class="keyword">val</span> pc_of_lval : 
  <span><span class="xref-unresolved">Frama_c_kernel</span>.Cil_types.lval <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../Pc/index.html#type-pc_lval">Pc.pc_lval</a>, string)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p>Converts a left-hand value (lval) into a PlusCal representation. Different cases of lvals to handle are variables, fields, and indexed elements.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">lval</span> <p>lvalue to be translated.</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p><code>Result</code> containing the translated PlusCal lvalue or an error message. *</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-init_to_pc_expr"><a href="#val-init_to_pc_expr" class="anchor"></a><code><span><span class="keyword">val</span> init_to_pc_expr : 
  <span><span><span class="xref-unresolved">Frama_c_kernel</span>.Cil_types.init option</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../Pc/index.html#type-pc_expr">Pc.pc_expr</a>, string)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p>Converts an optional initialization expression to a PlusCal expression.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">i</span> <p>optional initialization expression of type <code>init option</code>.</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p><code>Result</code> containing the translated PlusCal initialization or an error message. *</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-complex_type_to_pc_expr"><a href="#val-complex_type_to_pc_expr" class="anchor"></a><code><span><span class="keyword">val</span> complex_type_to_pc_expr : 
  <span><span class="xref-unresolved">Frama_c_kernel</span>.Cil_types.init <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../Pc/index.html#type-pc_expr">Pc.pc_expr</a>, string)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p>Converts a complex initialization type (array, struct, etc) to a PlusCal expression.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">i</span> <p>initialization to be converted.</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p><code>Result</code> containing the PlusCal initialization or an error message. *</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-handle_compound_init"><a href="#val-handle_compound_init" class="anchor"></a><code><span><span class="keyword">val</span> handle_compound_init : 
  <span><span><span>(<span class="xref-unresolved">Frama_c_kernel</span>.Cil_types.offset * <span class="xref-unresolved">Frama_c_kernel</span>.Cil_types.init)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../Pc/index.html#type-pc_expr">Pc.pc_expr</a>, string)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p>Handles the initialization of compound types (records or arrays).</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">l</span> <p>list of tuples where each tuple consists of an offset and an initializer.</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p><code>Result</code> containing parsed compound initializer or an error message. *</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-handle_record_init"><a href="#val-handle_record_init" class="anchor"></a><code><span><span class="keyword">val</span> handle_record_init : 
  <span><span><span>(<span class="xref-unresolved">Frama_c_kernel</span>.Cil_types.offset * <span class="xref-unresolved">Frama_c_kernel</span>.Cil_types.init)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../Pc/index.html#type-pc_expr">Pc.pc_expr</a>, string)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p>@function handle_record_init</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">l</span> <p>list of tuples where each tuple consists of a field offset and an initializer.</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p><code>Result</code> containing parsed record initializer or an error message.</p></li></ul><p>@function handle_array_init</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">l</span> <p>list of tuples where each tuple consists of an index offset and an initializer.</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p><code>Result</code> containing parsed array initializer or an error message. *</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-handle_array_init"><a href="#val-handle_array_init" class="anchor"></a><code><span><span class="keyword">val</span> handle_array_init : 
  <span><span><span>(<span class="xref-unresolved">Frama_c_kernel</span>.Cil_types.offset * <span class="xref-unresolved">Frama_c_kernel</span>.Cil_types.init)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../Pc/index.html#type-pc_expr">Pc.pc_expr</a>, string)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pc_of_exp_list"><a href="#val-pc_of_exp_list" class="anchor"></a><code><span><span class="keyword">val</span> pc_of_exp_list : 
  <span><span><span class="xref-unresolved">Frama_c_kernel</span>.Cil_types.exp list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="../Pc/index.html#type-pc_expr">Pc.pc_expr</a> list</span>, string)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p>Takes a list of expressions <code>l</code> and processes each expression It accumulates the Ok results in a list, starting with an empty list.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">l</span> <p>list of expressions to be processed.</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p><code>Result</code> containing the list of processed expressions or an error if any expression fails to process.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pc_of_instr"><a href="#val-pc_of_instr" class="anchor"></a><code><span><span class="keyword">val</span> pc_of_instr : 
  <span><span class="xref-unresolved">Frama_c_kernel</span>.Cil_types.instr <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="../Pc/index.html#type-pc_instr">Pc.pc_instr</a> list</span>, string)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p>Converts an instruction to a PlusCal representation.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">instr</span> <p>instruction to convert.</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p><code>Result</code> containing a list of PlusCal instructions or an error message.</p></li></ul><p>The function does not handle the following cases :</p><ul><li><code>Asm</code> : Assembly code</li><li><code>Code_annot</code> : Code annotation *</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pc_of_stmt"><a href="#val-pc_of_stmt" class="anchor"></a><code><span><span class="keyword">val</span> pc_of_stmt : 
  <span><span class="xref-unresolved">Frama_c_kernel</span>.Cil_types.stmtkind <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="../Pc/index.html#type-pc_instr">Pc.pc_instr</a> list</span>, string)</span> <span class="xref-unresolved">Stdlib</span>.result</span> * int</span></code></div><div class="spec-doc"><p>Recursively generates PlusCal code from a given statement.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">stmt</span> <p>statement to be converted to PlusCal code.</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>tuple containing:</p><ul><li><code>Result</code> type with a list of PlusCal instructions or an error message.</li><li><code>Integer</code> representing the number of statements to skip after this one This is used not to handle statement already handle, for ex. after a Block</li></ul></li></ul><p>The function does not handle the following cases :</p><ul><li><code>Try</code></li><li><code>Throw</code></li><li><code>Continue</code></li><li><code>Switch</code> *</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pc_of_block"><a href="#val-pc_of_block" class="anchor"></a><code><span><span class="keyword">val</span> pc_of_block : 
  <span><span><span class="xref-unresolved">Frama_c_kernel</span>.Cil_types.stmt list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="../Pc/index.html#type-pc_instr">Pc.pc_instr</a> list</span>, string)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p>Converts a block of statements <code>b</code> into a list of PlusCal statements.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">b</span> <p>block of statements to convert.</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p><code>Result</code> containing the list of PlusCal statements or an error. *</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pc_constant_of_enum"><a href="#val-pc_constant_of_enum" class="anchor"></a><code><span><span class="keyword">val</span> pc_constant_of_enum : 
  <span><span class="xref-unresolved">Frama_c_kernel</span>.Cil_types.enumitem <span class="arrow">&#45;&gt;</span></span>
  <span><span>(string * int, string)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p>Converts an enum item <code>e</code> to a pair of its name and integer value.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">e</span> <p>enum item to be converted.</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p><code>Result</code> enum item has pair (name (str), value (int)) or an error constant value. *</p></li></ul></div></div><div class="odoc-spec"><div class="spec class anchored" id="class-gen_pc"><a href="#class-gen_pc" class="anchor"></a><code><span><span class="keyword">class</span> </span><span><a href="class-gen_pc/index.html">gen_pc</a></span><span> : <span><span><a href="../Pc/index.html#type-pc_prog">Pc.pc_prog</a> <span class="xref-unresolved">Stdlib</span>.ref</span> <span class="arrow">&#45;&gt;</span></span> <span class="keyword">object</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Class responsible for generating PlusCal code from a given Frama-C program. It inherits from <code>Visitor.frama_c_inplace</code>, which allows it to traverse and manipulate the Frama-C AST in place.</p></div></div></div></body></html>
