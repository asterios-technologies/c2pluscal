(**
    Generates PlusCal code from a given Frama-C program.
    The PlusCal code is generated by traversing the Frama-C AST and converting
    each element into its corresponding PlusCal representation.
**)

open Cil_types
open Pc
open Pc_utils

(**
  Converts a unary operation to its corresponding PlusCal representation.
  @param unop unary operation to convert.
  @return [Result] containing the PlusCal unary operation or an error message.
**)
let pc_of_unop = function
  | Neg -> PMinus
  | LNot -> PNot
  | BNot -> PBnot


(**
  Converts a unary operation to its corresponding PlusCal representation.
  @param binop binary operation to convert.
  @return [Result] containing the PlusCal binary operation or an error message.
**)
let pc_of_binop = function
  | PlusA -> PAdd | PlusPI -> PAddPI
  | MinusA -> PSub | MinusPI -> PSubPI | MinusPP -> PSubPP
  | Mult -> PMul | Div -> PDiv | Mod -> PMod
  | Lt -> PLt | Gt -> PGt | Le -> PLe | Ge -> PGe
  | Eq -> PEq | Ne -> PNe
  | LAnd -> PLand | LOr -> PLor
  | Shiftlt -> PShiftL | Shiftrt -> PShiftR
  | BAnd -> PBand | BXor -> PBxor | BOr -> PBor


(**
  Converts a constant to a PlusCal expression.
    @param cst constant to convert.
    @return [Result] containing the PlusCal constant or an error message.

  The function does not handle the following cases :
    - [CWStr] : Wide character string
    - [CReal] : Floating point number
**)
let pc_of_cst = function
  | CInt64 (int,_,_) -> (try Result.ok (PInt(Integer.to_int_exn int)) with
                           | _ -> Result.error "Integer out of range")
  | CStr str -> Result.ok (PString str)
  | CChr char -> Result.ok (PString (String.make 1 char))
  | CEnum item -> Result.ok (PEnumItem item.einame)
  | _ -> Result.error "pc_of_cst: Constant not treated"


(**
  Recursively translates an expression into its PlusCal representation.
  @param exp expression to be translated.
  @return [Result] containing the PlusCal expression or an error message.

  The function does not handle the following cases :
    - [SizeOf]
    - [AlignOf]
**)
let rec pc_of_exp = function
  (*C constant*)
  | Const c ->
      pc_of_cst c
      |> Result.map (fun pc_cst -> PCst pc_cst)

  (*Lvalue*)
  | Lval lval ->
    pc_of_lval lval
    |> Result.map (fun pc_lval -> PLval pc_lval)

  (*Unary operation*)
  | UnOp (u,e, _) ->
      let pc_unop = pc_of_unop u in
      pc_of_exp e.enode
      |> Result.map (fun pc_exp -> PUnop (pc_unop,pc_exp))

  (*Binary operation*)
  | BinOp (b, e1, e2, _) ->
      let pc_binop = pc_of_binop b in
      Result.bind (pc_of_exp e1.enode) (fun pc_exp1 ->
        pc_of_exp e2.enode
        |> Result.map (fun pc_exp2 -> PBinop (pc_binop,pc_exp1,pc_exp2)))

  (*Address of an lvalue*)
  | AddrOf lval
  | StartOf lval ->
      (*[AddrOf] takes the address of an lvalue
        [StartOf] converts an array to a pointer when passed to a function.
        Our PlusCal representation treats arrays as variables, so we treat [StartOf] as [AddrOf].

        We have two cases :
        1. Address of a variable.
        2. Address from memory access, handled by an external function [mem_translate].*)
      (match fst lval with
        | Var vinfo -> Result.ok (PAddr (PLVar (vinfo.vorig_name, vinfo.vglob)))
        | Mem e -> pc_of_mec_access e
                   |> Result.map (fun pc_lval -> PAddr (pc_lval))
      )

  (*Cast of an expression*)
  | CastE(_,e) -> pc_of_exp e.enode
  | e -> Result.error (Printf.sprintf "pc_of_exp: Expression not treated: %s\n" (exp_to_str e))


(**
  Translates a memory access expression [e] into a PlusCal expression.
  It uses the [pc_of_exp] function to convert the expression node [e.enode] into a PlusCal expression.
  @param e expression to be translated.
  @return [Result] containing the translated PlusCal expression or an error message.
**)
and pc_of_mec_access (e: exp) = Result.bind (pc_of_exp e.enode) (fun pc_exp_mem ->
  (match pc_exp_mem with
    (*Converts access to variable or pointer into load operation*)
    (*Example : *x
        - (pc_of_exp) -> PLVal(PLVar(x))
        - (pc_of_mec_access) -> PLoad(PLVal(PLVar(x)))

                **x
        - (pc_of_exp) -> PLVal(PLVar(x))
        - (pc_of_mec_access) -> PLoad(PLVal(PLVar(x)))
        - (pc_of_mec_access) -> PLoad(PLoad(PLVal(PLVar(x))))*)
    | PLval (PLVar (ptr_info)) -> Result.ok (PLoad (PLVar (ptr_info)))
    | PLval (PLoad (pc_lval)) -> Result.ok (PLoad (PLoad (pc_lval)))

    (*Does not change access to a field or index, because our they are not stored in the stack as in C*)
    | PLval (PField (field_info)) -> Result.ok (PField (field_info))
    | PLval (PIndex (idx_info)) -> Result.ok (PIndex (idx_info))

    (* Converts a binary pointer operation to an index access *)
    (* Example : arr[2]
        - (pc_of_exp) -> PBinop(PAddPI, PLval(arr), PCst(2))
        - (pc_of_mec_access) -> PIndex(PCst(2), PLval(arr)) *)
    | PBinop (PAddPI, PLval (pc_lval), e2)
    | PBinop (PSubPI, PLval (pc_lval), e2) ->
      (*Add 1 to the index, because TLA sequences indexes begins at 1*)
      let pc_exp = add_pc_cst e2 1 in Result.ok (PIndex (pc_exp, pc_lval))

    (*Example : arr[i]
        - (pc_of_exp) -> PBinop(PAddPI, PLval(arr), PLVal(i))
        - (pc_of_mec_access) -> PIndex(PLVal(i), PLVal(arr))*)
    | PBinop (PSubPP, PLval (pc_lval), PLval (pc_lval2)) ->  Result.ok (PIndex (PLval (pc_lval2), pc_lval))
    | _ -> Result.error (Printf.sprintf "pc_of_mec_access: Memory access not treated: %s" (exp_to_str e.enode))
  ))


(**
  Converts a left-hand value (lval) into a PlusCal representation.
  Different cases of lvals to handle are variables, fields, and indexed elements.
  @param lval lvalue to be translated.
  @return [Result] containing the translated PlusCal lvalue or an error message.
**)
and pc_of_lval = function
  (*Converts a lvalue with no offset into a PlusCal variable.*)
  | Var vinfo, NoOffset -> Result.ok (PLVar ((vinfo.vorig_name, vinfo.vglob)))
  | Mem e, NoOffset -> pc_of_mec_access e

  (*Converts a lvalue field into a PlusCal field.*)
  | Var vinfo, Field(finfo,_) ->
      Result.ok (PField (finfo.fname, PLVar (vinfo.vorig_name, vinfo.vglob)))
  | Mem e, Field(finfo,_) ->
      pc_of_mec_access e
      |> Result.map (fun pc_lval ->
         PField (finfo.fname, pc_lval))

  (*Converts a lvalue indexed element into a PlusCal index.*)
  | Var vinfo, Index(e,_) ->
    pc_of_exp e.enode
    |> Result.map (fun pc_exp ->
      (*Add 1 to the index, because TLA sequences indexes begins at 1*)
      let pc_exp = add_pc_cst pc_exp 1 in
      PIndex (pc_exp, PLVar (vinfo.vorig_name, vinfo.vglob)))
  | Mem e, Index(e',_) ->
    Result.bind (pc_of_exp e'.enode) (fun pc_exp ->
      (*Add 1 to the index, because TLA sequences indexes begins at 1*)
      let pc_exp = add_pc_cst pc_exp 1 in
      pc_of_mec_access e
      |> Result.map (fun pc_lval ->
         PIndex (pc_exp, pc_lval)))


(**
  Converts an optional initialization expression to a PlusCal expression.
  @param i optional initialization expression of type [init option].
  @return [Result] containing the translated PlusCal initialization or an error message.
**)
let rec init_to_pc_expr (i: init option) =
  match i with
    (*No init -> PUndef*)
    | None -> Result.ok PUndef
    | Some init ->
       match init with
        | CompoundInit _ -> complex_type_to_pc_expr init
        | SingleInit e -> pc_of_exp e.enode

(**
  Converts a complex initialization type (array, struct, etc) to a PlusCal expression.
  @param i initialization to be converted.
  @return [Result] containing the PlusCal initialization or an error message.
**)
and complex_type_to_pc_expr (i: init) =
  match i with
  | CompoundInit (_, l) -> handle_compound_init l
  | _ -> Result.error "complex_type_to_pc_expr: Entry should be CompoundInit"

(**
  Handles the initialization of compound types (records or arrays).
  @param l list of tuples where each tuple consists of an offset and an initializer.
  @return [Result] containing parsed compound initializer or an error message.
**)
and handle_compound_init l =
  match List.length l with
  | 0 -> Result.ok PUndef
  (*Checks the first element of the list to know which type of init*)
  | _ -> (match List.hd l with
          | (Field(_), _) -> handle_record_init l
          | (Index(_), _) -> handle_array_init l
          | _ -> Result.error "handle_compound_init: Offset should be Index or Field in compound init"
         )

(**
  @function handle_record_init
  @param l list of tuples where each tuple consists of a field offset and an initializer.
  @return [Result] containing parsed record initializer or an error message.

  @function handle_array_init
  @param l list of tuples where each tuple consists of an index offset and an initializer.
  @return [Result] containing parsed array initializer or an error message.
**)
and handle_record_init l =
  (*Result list of (string * pc_expr) to initialize the record*)
  let record_result =
    fold_left_result
      (fun (offs, i) -> match offs with
         | Field(f, _) -> init_to_pc_expr (Some i) |> Result.map (fun ok_init -> (f.fname, ok_init))
         | _ -> Result.error "handle_record_init: Offset should be Field in struct init")
      (fun acc i -> acc @ [i]) [] l
  in
  record_result |> Result.map (fun ok_record -> PCst (PRecord ok_record))

and handle_array_init l =
  (*Result list of (pc_expr * pc_expr) to initialize the array*)
  let array_result =
    fold_left_result
      (fun (offs, i) -> match offs with
         | Index(_, _) -> init_to_pc_expr (Some i)
         | _ -> Result.error "handle_array_init: Offset should be Index in array init")
      (fun acc i -> acc @ [i]) [] l
  in
  array_result |> Result.map (fun ok_array -> PCst (PArray ok_array))


(**
  Takes a list of expressions [l] and processes each expression
  It accumulates the Ok results in a list, starting with an empty list.
  @param l list of expressions to be processed.
  @return [Result] containing the list of processed expressions or an error if any expression fails to process.
*)
let pc_of_exp_list l = fold_left_result (fun e -> pc_of_exp e.enode) (fun acc e -> acc@[e]) [] l


(**
  Converts an instruction to a PlusCal representation.
  @param instr instruction to convert.
  @return [Result] containing a list of PlusCal instructions or an error message.

  The function does not handle the following cases :
    - [Asm] : Assembly code
    - [Code_annot] : Code annotation
**)
let pc_of_instr = function
  (*Assignment*)
  | Set(lval, e, _) ->
      Result.bind (pc_of_exp e.enode) (fun pc_exp ->
        pc_of_lval lval
        |> Result.map (fun pc_lval ->
           ([PStore (pc_exp, pc_lval)])))

  (*Function call*)
  (*lval option as call result*)
  (*expression to store function as a variable*)
  (*expression list used store function's args*)
  | Call(lval_opt, e, e_list, _) ->
      Result.bind (pc_of_exp_list e_list) (fun pc_exp_list ->
        Result.bind (pc_of_exp e.enode) (fun pc_exp ->
          (match pc_exp with
            | PLval (PLVar (fname, _)) ->
              (match lval_opt with
                |Some lval -> Result.bind (pc_of_lval lval) (fun pc_lval ->
                                Result.ok ([PCall (fname, pc_exp_list);
                                            PRetAttr ((pc_lval))]))
                |None -> Result.ok ([PCall (fname, pc_exp_list)])
              )
            | _ -> Result.error "pc_of_instr: Call instr should have PLval(PLVar()) exp"
          )))

  (*Initialization of a variable*)
  | Local_init (vinfo, local_init, _) ->
    (match local_init with
      (*Init with a constant*)
      | AssignInit init ->
        init_to_pc_expr (Some init)
        |> Result.map (fun pc_init ->
          ([PStore (pc_init, PLVar (vinfo.vorig_name, vinfo.vglob))]))
      (*Init with a call to a function*)
      | ConsInit (finfo, args, _) ->
        pc_of_exp_list args
        |> Result.map (fun pc_args_list ->
           [PCall (finfo.vorig_name, pc_args_list);
           PRetAttr (PLVar (vinfo.vorig_name, vinfo.vglob))])
    )

  (*No instruction if we have a skip*)
  | Skip _ -> Result.ok ([])
  | i -> Result.error (Printf.sprintf "pc_of_instr: Instr not treated %s" (instr_to_str i))


(**
  Recursively generates PlusCal code from a given statement.
  @param stmt statement to be converted to PlusCal code.
  @return tuple containing:
    - [Result] type with a list of PlusCal instructions or an error message.
    - [Integer] representing the number of statements to skip after this one
      This is used not to handle statement already handle, for ex. after a Block

  The function does not handle the following cases :
    - [Try]
    - [Throw]
    - [Continue]
    - [Switch]
**)
let rec pc_of_stmt = function
  (*Instruction*)
  | Instr i -> (pc_of_instr i, 0)

  (*Return of a function*)
  | Return (r,_) ->
    (match r with
      | Some e -> (pc_of_exp e.enode) |> Result.map (fun ok_exp -> [PReturn ok_exp]), 0
      | None -> Result.ok [], 0
    )

  (*Goto*)
  | Goto (r,_) -> (Result.ok [PGoto (Pretty_utils.to_string Printer.pp_label (List.hd (!r).labels))], 0)

  (*If statement*)
  | If (e,b1,b2,_) ->
    let pc_if =
    Result.bind (pc_of_exp e.enode) (fun ok_exp ->
      Result.bind (pc_of_block b1.bstmts) (fun ok_b1 ->
        Result.bind (pc_of_block b2.bstmts) (fun ok_b2 ->
          Result.ok [PIf (ok_exp, ok_b1, ok_b2)])))
    in

    if Result.is_error pc_if then pc_if, 0
    else pc_if, List.length b1.bstmts + List.length b2.bstmts

  (*Loop statement*)
  (*All loops are transformated into while(1) loop*)
  | Loop (_,b,_,_,s) ->
      (match s with
        |None -> Result.error "pc_of_stmt: Break stmts in Loop should appear", 0
        |Some(s) ->
          pc_of_block b.bstmts
          |> Result.map (fun pc_block ->
             [PWhile (pc_block, Pretty_utils.to_string Printer.pp_label (List.hd s.labels))]), List.length b.bstmts+1
      )

  (*Break statement*)
  | Break loc -> Result.ok ([PGoto (Pretty_utils.to_string Printer.pp_location loc)]), 0

  (*Block of instruction*)
  | Block b -> pc_of_block b.bstmts, List.length b.bstmts

  (*Unspecified sequence*)
  (*Handled as block*)
  | UnspecifiedSequence l ->
    let block = (Cil.block_from_unspecified_sequence l).bstmts in pc_of_block block, List.length block

  | s -> Result.error (Printf.sprintf "pc_of_stmt: Stmt not treated %s" (stmt_to_str s)), 0


(**
  Converts a block of statements [b] into a list of PlusCal statements.
  @param b block of statements to convert.
  @return [Result] containing the list of PlusCal statements or an error.
**)
and pc_of_block b =
  (*Empty block*)
  if List.length b = 0 then
    Result.ok ([PSkip])
  else
    (*Fold all stmt translation*)
    fold_left_result (fun s -> fst (pc_of_stmt s.skind)) (fun acc s_list -> acc@s_list) [] b


(**
  Converts an enum item [e] to a pair of its name and integer value.
  @param e enum item to be converted.
  @return [Result] enum item has pair (name (str), value (int)) or an error constant value.
**)
let pc_constant_of_enum (e: enumitem) = match e.eival.enode with
    | Const(CInt64(i,_,_)) -> Result.ok (e.einame, Integer.to_int_exn i)
    | _ -> Result.error "pc_constant_of_enum: Enum item should have int constant value"


(**
  Class responsible for generating PlusCal code from a given
  Frama-C program. It inherits from [Visitor.frama_c_inplace], which allows it
  to traverse and manipulate the Frama-C AST in place.

  @param prog reference to a [pc_prog] object, which represents the PlusCal
              program to be generated.
  @val child_to_skip reference to an integer that keeps track of the number
                     of child nodes to skip during traversal.
  @val array_args_table reference to a hash table that stores information
                        about array arguments, with an initial size of 100.
**)
class gen_pc (prog: pc_prog ref) = object
  inherit Visitor.frama_c_inplace

  val child_to_skip = ref 0;
  val array_args_table = ref (Hashtbl.create 100);

  (*
    Processes a file in the PlusCal plugin.
    @param f file of the C code
    @return action to take after processing the file

    Updates the pc_prog by computing entry_point and name of the file
    Adds one main process to the pc_prog and one process that initializes global variable
  *)
  method! vfile f =
    let entry_point = get_entry_point f and
        name = get_file_name() and
        nb_process =  1 in
    let processus = [{pc_process_name="proc";
                      pc_process_set="PROCESS";
                      pc_process_vars=[];
                      pc_process_body=[PAwaitInit; PCall (entry_point,[])]}]
    in

      (*Computes the args of function in the program which are array*)
      (*Useful because those are transformed in pointer by Frama-C*)
      get_all_array_args !array_args_table f.globals;

      prog := {!prog with
               pc_prog_name = name;
               pc_entry_point = entry_point;
               pc_nb_process = nb_process;
               pc_processus = processus};

      Cil.DoChildrenPost(fun f ->
        (*Add the process that initializes global variable*)
        let glob_init_process =
          {pc_process_name="globalInit";
          pc_process_set="GLOBAL_INIT";
          pc_process_vars=[];

          pc_process_body=(List.fold_left
          (* A variable is represented here as a tuple (str, int option).
             The second parameter indicates if the variable is an array, providing its size if it is. *)
          (fun acc ((name, int_opt),expr) ->
            (*If the variable is an array, call to init_array procedure*)
            match int_opt with
              |Some array_size -> PDecl (PUndef, (name,true))::(PInitArray (array_size, (name,true))::acc)
              |None -> PDecl (expr, (name,true))::acc) [] (!prog).pc_glob_var)@[PInitDone]
          }
        in
        prog := {!prog with
                  pc_processus = glob_init_process::(!prog).pc_processus};f)


  (*
    Processes global declarations in the CIL AST and updates the program state accordingly.
    @param g global declaration to process.
    @return action to take after processing the global declaration.

    The method does not handle the following cases :
      - [GAsm] : global assembly code
      - [GPragma] : pragmas at top level
      - [GText] : text at top level
      - [GAnnot] : global annotation
      - [GType] : typedef
      - [GDecl] : declaration (variable, function, etc.)
  *)
  method! vglob_aux g =
    match g with
      (*Global variable*)
      | GVar(varinfo, initinfo, _) ->
          prog := {!prog with
                    pc_glob_var =
                      (*Process variable and init before adding to pc_prog*)
                      (varinfo_is_array varinfo, Result.get_ok (init_to_pc_expr initinfo.init))
                      ::(!prog).pc_glob_var;
                  };
          Cil.DoChildren

      (*Struct/Union tag*)
      (*Will be handle in complex_type_to_pc_expr later*)
      | GCompTag(_, _) -> Cil.DoChildren

      (*Enum tag*)
      | GEnumTag (enuminfo,_) ->
        (*Folds enum item as a list of (name (str), value (int))*)
        (match fold_left_result (fun e -> pc_constant_of_enum e) (fun acc e -> acc@[e]) [] enuminfo.eitems with
          |Error e -> Printf.eprintf "Error : %s" e; Cil.DoChildren
          |Ok enum_items ->
            prog := {!prog with
                     (*Add the items as TLA constants*)
                     pc_constants = (!prog).pc_constants@enum_items
                    };
            Cil.DoChildren
        )

      (*Function*)
      | GFun(fundec, _) ->
          Cfg.prepareCFG fundec;
          let proc_name = fundec.svar.vorig_name in

          (*Process args and local vars of the function*)
          let args = List.map (varinfo_is_array) fundec.sformals and
              vars = List.map (varinfo_is_array) fundec.slocals in

          (*Declaration instructions of args and local vars of the function*)
          let (args_decl,nb_args_decl) = procedure_push_vars ([],0) args
              (true,(Hashtbl.find_all !array_args_table proc_name),(List.length args))
          and
              (vars_decl,nb_vars_decl) = procedure_push_vars ([],0) vars (false,[],0) in

          (*Pop instructions to put at the end of the function*)
          let pop_list = procedure_pop [] (nb_args_decl + nb_vars_decl) in

            prog := {!prog with
                    pc_procedures =
                      {pc_procedure_name=proc_name;
                       pc_procedure_args=List.map (fun vinfo -> vinfo.vorig_name) fundec.sformals;
                       pc_procedure_vars=List.map (fun vinfo -> vinfo.vorig_name) fundec.slocals;
                       pc_procedure_body=args_decl@vars_decl
                      }::(!prog).pc_procedures;
                    };

            Cil.DoChildrenPost(fun g ->
            match (!prog).pc_procedures with
            |curr_proc::q ->
              (*Add a label to check invariant in the procedure*)
              (*Only if the option is given in frama-c params*)
              let check_label = if (List.mem (curr_proc.pc_procedure_name) (Options.CheckFun.get()))
                then [PLabel ("Check_"^curr_proc.pc_procedure_name^":"); PSkip] else []
              in
              prog := {!prog with
                        pc_procedures =
                         {curr_proc with
                            pc_procedure_body=
                            curr_proc.pc_procedure_body@
                            check_label@ (*Check Label*)
                            pop_list (*Pop instructions*)
                          }::q;
                      }; g
            |[] -> Printf.eprintf "vglob_aux: Error no procedure"; g)

      | _ -> Cil.DoChildren


  (*
    Processes statements in the CIL AST and updates the program state accordingly.
    @param s statement to process.
    @return action to take after processing the statement.
  *)
  method! vstmt_aux s =
    (*Checks if there are statements to skip and skips them if so*)
    match !child_to_skip with |i when i > 0 ->
    child_to_skip := !child_to_skip - 1;
    Cil.SkipChildren

    |_ ->
    let (pc_instrs_result,nb_skip) = pc_of_stmt s.skind in
    child_to_skip := nb_skip;

    match pc_instrs_result with
      (*There was an error in the statement process*)
      | Error e -> Printf.eprintf "Error : %s" e; Cil.DoChildren

      | Ok pc_instrs ->
        match (!prog).pc_procedures with
          |curr_proc::q ->
            (match s.labels with
              |[] -> prog :=
                      {!prog with
                      pc_procedures =
                        {curr_proc with
                          pc_procedure_body=
                          curr_proc.pc_procedure_body@
                          pc_instrs}::q;
                      };
              Cil.DoChildren

              (*The statement has label*)
              |lbl::_ -> prog :=
                        {!prog with
                        pc_procedures =
                          {curr_proc with
                            pc_procedure_body=
                            curr_proc.pc_procedure_body@
                            (*Add the label to the instruction body*)
                            (PLabel (Pretty_utils.to_string Printer.pp_label lbl)
                            ::pc_instrs)}::q;
                        };
              Cil.DoChildren
            )
          |[] -> Printf.eprintf "vstmt_aux: Error no procedure"; Cil.DoChildren
end